# -*- coding: utf-8 -*-
"""AG.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Id4ugjeKPis5ZWfJFvK57hF9V598JjN_
"""

import numpy as np
import matplotlib.pyplot as plt
import random
import re
import os
import urllib.request
import csv

# === Téléchargement automatique du fichier VRP ===
filename = 'X-n101-k25.vrp'
url = 'http://vrp.galgos.inf.puc-rio.br/media/com_vrp/instances/X/X-n101-k25.vrp'

if not os.path.exists(filename):
    print("Téléchargement de l'instance...")
    urllib.request.urlretrieve(url, filename)
    print("Téléchargement terminé.")

# === Lecture fichier VRP ===
def read_vrp_file(filename):
    with open(filename, 'r') as file:
        lines = file.readlines()

    dimension = int(re.search(r'DIMENSION\s*:\s*(\d+)', ''.join(lines)).group(1))
    capacity = int(re.search(r'CAPACITY\s*:\s*(\d+)', ''.join(lines)).group(1))

    node_coord_start = next(i for i, line in enumerate(lines) if 'NODE_COORD_SECTION' in line)
    demand_start = next(i for i, line in enumerate(lines) if 'DEMAND_SECTION' in line)
    depot_start = next(i for i, line in enumerate(lines) if 'DEPOT_SECTION' in line)

    coords = np.zeros((dimension, 2))
    for i in range(node_coord_start + 1, demand_start):
        parts = lines[i].split()
        coords[int(parts[0]) - 1] = [float(parts[1]), float(parts[2])]

    demands = np.zeros(dimension, dtype=int)
    for i in range(demand_start + 1, depot_start):
        parts = lines[i].split()
        demands[int(parts[0]) - 1] = int(parts[1])

    depot = int(lines[depot_start + 1].strip()) - 1
    return coords, demands, depot, capacity

coords, demands, depot, capacity = read_vrp_file(filename)

# === Calcul matrice de distances euclidiennes ===
def calculate_distance_matrix(coords):
    n = len(coords)
    dist_matrix = np.zeros((n, n))
    for i in range(n):
        for j in range(i+1, n):
            dist = np.linalg.norm(coords[i] - coords[j])
            dist_matrix[i, j] = dist
            dist_matrix[j, i] = dist
    return dist_matrix

dist_matrix = calculate_distance_matrix(coords)

# === Fitness : coût total de la solution (somme des distances des tournées) ===
def calculate_cost(routes, dist_matrix):
    cost = 0
    for route in routes:
        if len(route) == 0:
            continue
        cost += dist_matrix[depot, route[0]]  # depot -> 1er client
        for i in range(len(route) - 1):
            cost += dist_matrix[route[i], route[i+1]]
        cost += dist_matrix[route[-1], depot]  # dernier client -> depot
    return cost

# === Construction d'une solution à partir d'une permutation et séparation en tournées ===
def split_routes(permutation, demands, capacity):
    routes = []
    route = []
    load = 0
    for node in permutation:
        demand = demands[node]
        if load + demand <= capacity:
            route.append(node)
            load += demand
        else:
            routes.append(route)
            route = [node]
            load = demand
    if route:
        routes.append(route)
    return routes

# === Initialisation population ===
def init_population(pop_size, n_customers):
    population = []
    base_perm = list(range(1, n_customers))  # exclure depot (0)
    for _ in range(pop_size):
        perm = base_perm[:]
        random.shuffle(perm)
        population.append(perm)
    return population

# === Sélection par tournoi ===
def tournament_selection(population, fitnesses, k=3):
    selected = random.sample(list(zip(population, fitnesses)), k)
    selected.sort(key=lambda x: x[1])
    return selected[0][0]

# === Crossover Order 1 (OX1) ===
def crossover(parent1, parent2):
    size = len(parent1)
    a, b = sorted(random.sample(range(size), 2))
    child = [None] * size
    child[a:b+1] = parent1[a:b+1]

    fill_pos = (b+1) % size
    parent2_pos = (b+1) % size
    while None in child:
        if parent2[parent2_pos] not in child:
            child[fill_pos] = parent2[parent2_pos]
            fill_pos = (fill_pos + 1) % size
        parent2_pos = (parent2_pos + 1) % size
    return child

# === Mutation swap ===
def mutation(perm, mutation_rate=0.002):
    perm = perm[:]
    for i in range(len(perm)):
        if random.random() < mutation_rate:
            j = random.randint(0, len(perm) -1)
            perm[i], perm[j] = perm[j], perm[i]
    return perm

# === Algorithme génétique principal ===
def genetic_algorithm(coords, demands, depot, capacity, dist_matrix,
                      pop_size=50, generations=100, mutation_rate=0.1):
    n_customers = len(coords)
    population = init_population(pop_size, n_customers)

    best_perm = None
    best_cost = float('inf')
    best_routes = None

    for gen in range(generations):
        fitnesses = []
        for perm in population:
            routes = split_routes(perm, demands, capacity)
            cost = calculate_cost(routes, dist_matrix)
            fitnesses.append(cost)

            if cost < best_cost:
                best_cost = cost
                best_perm = perm
                best_routes = routes

        new_population = []
        for _ in range(pop_size):
            parent1 = tournament_selection(population, fitnesses)
            parent2 = tournament_selection(population, fitnesses)
            child = crossover(parent1, parent2)
            child = mutation(child, mutation_rate)
            new_population.append(child)
        population = new_population

    return best_routes, best_cost

# === Exécution 30 fois et sauvegarde des résultats ===
costs = []
num_routes = []
solutions = []
for i in range(30):
    print(f"Run {i+1}/30")
    routes, cost = genetic_algorithm(coords, demands, depot, capacity, dist_matrix)
    costs.append(cost)
    num_routes.append(len(routes))
    solutions.append((routes, cost))
    print(f"Coût total pour le run {i+1}: {cost:.2f}")

# === Meilleure solution globale ===
best_index = np.argmin(costs)
best_routes, best_cost = solutions[best_index]
best_num_routes = len(best_routes)

print(f"\nMeilleure solution sur 30 runs:")
print(f"Coût total = {best_cost:.2f}")
print(f"Nombre de tournées = {best_num_routes}")

# === Sauvegarde de la meilleure solution dans CSV ===
csv_filename = "best_solution_cvrp.csv"
with open(csv_filename, 'w', newline='') as csvfile:
    writer = csv.writer(csvfile)
    writer.writerow(['Route', 'Clients'])
    for i, route in enumerate(best_routes):
        # +1 pour client indexation humaine (optionnel)
        clients_str = ' '.join(str(c+1) for c in route)
        writer.writerow([f"Tournée {i+1}", clients_str])

print(f"Meilleure solution sauvegardée dans {csv_filename}")

# === Tracé évolution du coût sur 30 runs ===
plt.figure(figsize=(10,5))
plt.plot(range(1,31), costs, marker='o')
plt.title("Évolution du coût total (distance) sur 30 runs")
plt.xlabel("Run")
plt.ylabel("Coût total")
plt.grid(True)
plt.show()

# === Tracé des tournées de la meilleure solution ===
plt.figure(figsize=(8,8))
colors = plt.cm.get_cmap('tab20', best_num_routes)

for i, route in enumerate(best_routes):
    route_coords = coords[np.array(route)]
    depot_coord = coords[depot]
    # Tracer le dépôt (une seule fois)
    plt.plot(depot_coord[0], depot_coord[1], 'rs', markersize=8, label='Dépôt' if i == 0 else "")
    # Ligne dépôt -> premier client
    plt.plot([depot_coord[0], route_coords[0][0]], [depot_coord[1], route_coords[0][1]], color=colors(i))
    # Lignes entre clients
    plt.plot(route_coords[:,0], route_coords[:,1], marker='o', color=colors(i), label=f"Tournée {i+1}")
    # Ligne dernier client -> dépôt
    plt.plot([route_coords[-1][0], depot_coord[0]], [route_coords[-1][1], depot_coord[1]], color=colors(i))

plt.title("Meilleure solution CVRP (tournées)")
plt.legend()
plt.grid(True)
plt.show()

from google.colab import files
uploaded = files.upload()

import numpy as np
import matplotlib.pyplot as plt
import random
import re
import csv

# === Lecture fichier VRP pour A-n32-k5.vrp ===
def read_vrp_file(filename):
    with open(filename, 'r') as file:
        lines = file.readlines()

    dimension = int(re.search(r'DIMENSION\s*:\s*(\d+)', ''.join(lines)).group(1))
    capacity = int(re.search(r'CAPACITY\s*:\s*(\d+)', ''.join(lines)).group(1))

    node_coord_start = next(i for i, line in enumerate(lines) if 'NODE_COORD_SECTION' in line)
    demand_start = next(i for i, line in enumerate(lines) if 'DEMAND_SECTION' in line)
    depot_start = next(i for i, line in enumerate(lines) if 'DEPOT_SECTION' in line)

    coords = np.zeros((dimension, 2))
    for i in range(node_coord_start + 1, demand_start):
        parts = lines[i].split()
        coords[int(parts[0]) - 1] = [float(parts[1]), float(parts[2])]

    demands = np.zeros(dimension, dtype=int)
    for i in range(demand_start + 1, depot_start):
        parts = lines[i].split()
        demands[int(parts[0]) - 1] = int(parts[1])

    depot = int(lines[depot_start + 1].strip()) - 1
    return coords, demands, depot, capacity

coords, demands, depot, capacity = read_vrp_file('A-n32-k5.vrp')

# === Calcul matrice de distances euclidiennes ===
def calculate_distance_matrix(coords):
    n = len(coords)
    dist_matrix = np.zeros((n, n))
    for i in range(n):
        for j in range(i+1, n):
            dist = np.linalg.norm(coords[i] - coords[j])
            dist_matrix[i, j] = dist
            dist_matrix[j, i] = dist
    return dist_matrix

dist_matrix = calculate_distance_matrix(coords)

# === Fitness : coût total de la solution (somme des distances des tournées) ===
def calculate_cost(routes, dist_matrix):
    cost = 0
    for route in routes:
        if len(route) == 0:
            continue
        cost += dist_matrix[depot, route[0]]  # depot -> 1er client
        for i in range(len(route) - 1):
            cost += dist_matrix[route[i], route[i+1]]
        cost += dist_matrix[route[-1], depot]  # dernier client -> depot
    return cost

# === Construction d'une solution à partir d'une permutation et séparation en tournées ===
def split_routes(permutation, demands, capacity):
    routes = []
    route = []
    load = 0
    for node in permutation:
        demand = demands[node]
        if load + demand <= capacity:
            route.append(node)
            load += demand
        else:
            routes.append(route)
            route = [node]
            load = demand
    if route:
        routes.append(route)
    return routes

# === Initialisation population ===
def init_population(pop_size, n_customers):
    population = []
    base_perm = list(range(1, n_customers))  # exclure depot (0)
    for _ in range(pop_size):
        perm = base_perm[:]
        random.shuffle(perm)
        population.append(perm)
    return population

# === Sélection par tournoi ===
def tournament_selection(population, fitnesses, k=3):
    selected = random.sample(list(zip(population, fitnesses)), k)
    selected.sort(key=lambda x: x[1])
    return selected[0][0]

# === Crossover Order 1 (OX1) ===
def crossover(parent1, parent2):
    size = len(parent1)
    a, b = sorted(random.sample(range(size), 2))
    child = [None] * size
    child[a:b+1] = parent1[a:b+1]

    fill_pos = (b+1) % size
    parent2_pos = (b+1) % size
    while None in child:
        if parent2[parent2_pos] not in child:
            child[fill_pos] = parent2[parent2_pos]
            fill_pos = (fill_pos + 1) % size
        parent2_pos = (parent2_pos + 1) % size
    return child

# === Mutation swap ===
def mutation(perm, mutation_rate=0.002):
    perm = perm[:]
    for i in range(len(perm)):
        if random.random() < mutation_rate:
            j = random.randint(0, len(perm) -1)
            perm[i], perm[j] = perm[j], perm[i]
    return perm

# === Algorithme génétique principal ===
def genetic_algorithm(coords, demands, depot, capacity, dist_matrix,
                      pop_size=50, generations=100, mutation_rate=0.1):
    n_customers = len(coords)
    population = init_population(pop_size, n_customers)

    best_perm = None
    best_cost = float('inf')
    best_routes = None

    for gen in range(generations):
        fitnesses = []
        for perm in population:
            routes = split_routes(perm, demands, capacity)
            cost = calculate_cost(routes, dist_matrix)
            fitnesses.append(cost)

            if cost < best_cost:
                best_cost = cost
                best_perm = perm
                best_routes = routes

        new_population = []
        for _ in range(pop_size):
            parent1 = tournament_selection(population, fitnesses)
            parent2 = tournament_selection(population, fitnesses)
            child = crossover(parent1, parent2)
            child = mutation(child, mutation_rate)
            new_population.append(child)
        population = new_population

    return best_routes, best_cost

# === Exécution 30 fois et sauvegarde des résultats ===
costs = []
num_routes = []
solutions = []
for i in range(30):
    print(f"Run {i+1}/30")
    routes, cost = genetic_algorithm(coords, demands, depot, capacity, dist_matrix)
    costs.append(cost)
    num_routes.append(len(routes))
    solutions.append((routes, cost))
    print(f"Coût total pour le run {i+1}: {cost:.2f}")

# === Meilleure solution globale ===
best_index = np.argmin(costs)
best_routes, best_cost = solutions[best_index]
best_num_routes = len(best_routes)

print(f"\nMeilleure solution sur 30 runs:")
print(f"Coût total = {best_cost:.2f}")
print(f"Nombre de tournées = {best_num_routes}")

# === Sauvegarde de la meilleure solution dans CSV ===
csv_filename = "best_solution_A-n32-k5.csv"
with open(csv_filename, 'w', newline='') as csvfile:
    writer = csv.writer(csvfile)
    writer.writerow(['Route', 'Clients'])
    for i, route in enumerate(best_routes):
        clients_str = ' '.join(str(c+1) for c in route)  # +1 pour afficher index client humain
        writer.writerow([f"Tournée {i+1}", clients_str])

print(f"Meilleure solution sauvegardée dans {csv_filename}")

# === Tracé évolution du coût sur 30 runs ===
plt.figure(figsize=(10,5))
plt.plot(range(1,31), costs, marker='o')
plt.title("Évolution du coût total (distance) sur 30 runs - A-n32-k5")
plt.xlabel("Run")
plt.ylabel("Coût total")
plt.grid(True)
plt.show()

# === Tracé des tournées de la meilleure solution ===
plt.figure(figsize=(8,8))
colors = plt.cm.get_cmap('tab20', best_num_routes)

for i, route in enumerate(best_routes):
    route_coords = coords[np.array(route)]
    depot_coord = coords[depot]
    plt.plot(depot_coord[0], depot_coord[1], 'rs', markersize=8, label='Dépôt' if i == 0 else "")
    plt.plot([depot_coord[0], route_coords[0][0]], [depot_coord[1], route_coords[0][1]], color=colors(i))
    plt.plot(route_coords[:,0], route_coords[:,1], marker='o', color=colors(i), label=f"Tournée {i+1}")
    plt.plot([route_coords[-1][0], depot_coord[0]], [route_coords[-1][1], depot_coord[1]], color=colors(i))

plt.title("Meilleure solution CVRP (tournées) - A-n32-k5")
plt.legend()
plt.grid(True)
plt.show()

from google.colab import files
uploaded = files.upload()

import numpy as np
import matplotlib.pyplot as plt
import random
import re
import os
import urllib.request
import csv

# === Téléchargement automatique du fichier VRP ===
filename = 'P-n16-k8.vrp'
url = 'http://vrp.galgos.inf.puc-rio.br/media/com_vrp/instances/P/P-n16-k8.vrp'

if not os.path.exists(filename):
    print("Téléchargement de l'instance...")
    urllib.request.urlretrieve(url, filename)
    print("Téléchargement terminé.")

# === Lecture fichier VRP ===
def read_vrp_file(filename):
    with open(filename, 'r') as file:
        lines = file.readlines()

    dimension = int(re.search(r'DIMENSION\s*:\s*(\d+)', ''.join(lines)).group(1))
    capacity = int(re.search(r'CAPACITY\s*:\s*(\d+)', ''.join(lines)).group(1))

    node_coord_start = next(i for i, line in enumerate(lines) if 'NODE_COORD_SECTION' in line)
    demand_start = next(i for i, line in enumerate(lines) if 'DEMAND_SECTION' in line)
    depot_start = next(i for i, line in enumerate(lines) if 'DEPOT_SECTION' in line)

    coords = np.zeros((dimension, 2))
    for i in range(node_coord_start + 1, demand_start):
        parts = lines[i].split()
        coords[int(parts[0]) - 1] = [float(parts[1]), float(parts[2])]

    demands = np.zeros(dimension, dtype=int)
    for i in range(demand_start + 1, depot_start):
        parts = lines[i].split()
        demands[int(parts[0]) - 1] = int(parts[1])

    depot = int(lines[depot_start + 1].strip()) - 1
    return coords, demands, depot, capacity

coords, demands, depot, capacity = read_vrp_file(filename)

# === Calcul matrice de distances euclidiennes ===
def calculate_distance_matrix(coords):
    n = len(coords)
    dist_matrix = np.zeros((n, n))
    for i in range(n):
        for j in range(i+1, n):
            dist = np.linalg.norm(coords[i] - coords[j])
            dist_matrix[i, j] = dist
            dist_matrix[j, i] = dist
    return dist_matrix

dist_matrix = calculate_distance_matrix(coords)

# === Fitness : coût total de la solution (somme des distances des tournées) ===
def calculate_cost(routes, dist_matrix):
    cost = 0
    for route in routes:
        if len(route) == 0:
            continue
        cost += dist_matrix[depot, route[0]]  # depot -> 1er client
        for i in range(len(route) - 1):
            cost += dist_matrix[route[i], route[i+1]]
        cost += dist_matrix[route[-1], depot]  # dernier client -> depot
    return cost

# === Construction d'une solution à partir d'une permutation et séparation en tournées ===
def split_routes(permutation, demands, capacity):
    routes = []
    route = []
    load = 0
    for node in permutation:
        demand = demands[node]
        if load + demand <= capacity:
            route.append(node)
            load += demand
        else:
            routes.append(route)
            route = [node]
            load = demand
    if route:
        routes.append(route)
    return routes

# === Initialisation population ===
def init_population(pop_size, n_customers):
    population = []
    base_perm = list(range(1, n_customers))  # exclure depot (0)
    for _ in range(pop_size):
        perm = base_perm[:]
        random.shuffle(perm)
        population.append(perm)
    return population

# === Sélection par tournoi ===
def tournament_selection(population, fitnesses, k=3):
    selected = random.sample(list(zip(population, fitnesses)), k)
    selected.sort(key=lambda x: x[1])
    return selected[0][0]

# === Crossover Order 1 (OX1) ===
def crossover(parent1, parent2):
    size = len(parent1)
    a, b = sorted(random.sample(range(size), 2))
    child = [None] * size
    child[a:b+1] = parent1[a:b+1]

    fill_pos = (b+1) % size
    parent2_pos = (b+1) % size
    while None in child:
        if parent2[parent2_pos] not in child:
            child[fill_pos] = parent2[parent2_pos]
            fill_pos = (fill_pos + 1) % size
        parent2_pos = (parent2_pos + 1) % size
    return child

# === Mutation swap ===
def mutation(perm, mutation_rate=0.002):
    perm = perm[:]
    for i in range(len(perm)):
        if random.random() < mutation_rate:
            j = random.randint(0, len(perm) -1)
            perm[i], perm[j] = perm[j], perm[i]
    return perm

# === Algorithme génétique principal ===
def genetic_algorithm(coords, demands, depot, capacity, dist_matrix,
                      pop_size=50, generations=100, mutation_rate=0.1):
    n_customers = len(coords)
    population = init_population(pop_size, n_customers)

    best_perm = None
    best_cost = float('inf')
    best_routes = None

    for gen in range(generations):
        fitnesses = []
        for perm in population:
            routes = split_routes(perm, demands, capacity)
            cost = calculate_cost(routes, dist_matrix)
            fitnesses.append(cost)

            if cost < best_cost:
                best_cost = cost
                best_perm = perm
                best_routes = routes

        new_population = []
        for _ in range(pop_size):
            parent1 = tournament_selection(population, fitnesses)
            parent2 = tournament_selection(population, fitnesses)
            child = crossover(parent1, parent2)
            child = mutation(child, mutation_rate)
            new_population.append(child)
        population = new_population

    return best_routes, best_cost

# === Exécution 30 fois et sauvegarde des résultats ===
costs = []
num_routes = []
solutions = []
for i in range(30):
    print(f"Run {i+1}/30")
    routes, cost = genetic_algorithm(coords, demands, depot, capacity, dist_matrix)
    costs.append(cost)
    num_routes.append(len(routes))
    solutions.append((routes, cost))
    print(f"Coût total pour le run {i+1}: {cost:.2f}")

# === Meilleure solution globale ===
best_index = np.argmin(costs)
best_routes, best_cost = solutions[best_index]
best_num_routes = len(best_routes)

print(f"\nMeilleure solution sur 30 runs:")
print(f"Coût total = {best_cost:.2f}")
print(f"Nombre de tournées = {best_num_routes}")

# === Sauvegarde de la meilleure solution dans CSV ===
csv_filename = "best_solution_cvrp_p_n16_k8.csv"
with open(csv_filename, 'w', newline='') as csvfile:
    writer = csv.writer(csvfile)
    writer.writerow(['Route', 'Clients'])
    for i, route in enumerate(best_routes):
        clients_str = ' '.join(str(c+1) for c in route)
        writer.writerow([f"Tournée {i+1}", clients_str])

print(f"Meilleure solution sauvegardée dans {csv_filename}")

# === Tracé évolution du coût sur 30 runs ===
plt.figure(figsize=(10,5))
plt.plot(range(1,31), costs, marker='o')
plt.title("Évolution du coût total (distance) sur 30 runs")
plt.xlabel("Run")
plt.ylabel("Coût total")
plt.grid(True)
plt.show()

# === Tracé des tournées de la meilleure solution ===
plt.figure(figsize=(8,8))
colors = plt.cm.get_cmap('tab20', best_num_routes)

for i, route in enumerate(best_routes):
    route_coords = coords[np.array(route)]
    depot_coord = coords[depot]
    plt.plot(depot_coord[0], depot_coord[1], 'rs', markersize=8, label='Dépôt' if i == 0 else "")
    plt.plot([depot_coord[0], route_coords[0][0]], [depot_coord[1], route_coords[0][1]], color=colors(i))
    plt.plot(route_coords[:,0], route_coords[:,1], marker='o', color=colors(i), label=f"Tournée {i+1}")
    plt.plot([route_coords[-1][0], depot_coord[0]], [route_coords[-1][1], depot_coord[1]], color=colors(i))

plt.title("Meilleure solution CVRP (tournées) - P-n16-k8")
plt.legend()
plt.grid(True)
plt.show()

from google.colab import files
uploaded = files.upload()

import numpy as np
import matplotlib.pyplot as plt
import random
import re
import os
import urllib.request
import csv

# === Téléchargement automatique du fichier VRP ===
filename = 'B-n38-k6.vrp'
url = 'http://vrp.galgos.inf.puc-rio.br/media/com_vrp/instances/B/B-n38-k6.vrp'

if not os.path.exists(filename):
    print("Téléchargement de l'instance B-n38-k6...")
    urllib.request.urlretrieve(url, filename)
    print("Téléchargement terminé.")

# === Lecture fichier VRP ===
def read_vrp_file(filename):
    with open(filename, 'r') as file:
        lines = file.readlines()

    dimension = int(re.search(r'DIMENSION\s*:\s*(\d+)', ''.join(lines)).group(1))
    capacity = int(re.search(r'CAPACITY\s*:\s*(\d+)', ''.join(lines)).group(1))

    node_coord_start = next(i for i, line in enumerate(lines) if 'NODE_COORD_SECTION' in line)
    demand_start = next(i for i, line in enumerate(lines) if 'DEMAND_SECTION' in line)
    depot_start = next(i for i, line in enumerate(lines) if 'DEPOT_SECTION' in line)

    coords = np.zeros((dimension, 2))
    for i in range(node_coord_start + 1, demand_start):
        parts = lines[i].split()
        coords[int(parts[0]) - 1] = [float(parts[1]), float(parts[2])]

    demands = np.zeros(dimension, dtype=int)
    for i in range(demand_start + 1, depot_start):
        parts = lines[i].split()
        demands[int(parts[0]) - 1] = int(parts[1])

    depot = int(lines[depot_start + 1].strip()) - 1
    return coords, demands, depot, capacity

coords, demands, depot, capacity = read_vrp_file(filename)

# === Calcul matrice de distances euclidiennes ===
def calculate_distance_matrix(coords):
    n = len(coords)
    dist_matrix = np.zeros((n, n))
    for i in range(n):
        for j in range(i+1, n):
            dist = np.linalg.norm(coords[i] - coords[j])
            dist_matrix[i, j] = dist
            dist_matrix[j, i] = dist
    return dist_matrix

dist_matrix = calculate_distance_matrix(coords)

# === Fitness : coût total de la solution (somme des distances des tournées) ===
def calculate_cost(routes, dist_matrix):
    cost = 0
    for route in routes:
        if len(route) == 0:
            continue
        cost += dist_matrix[depot, route[0]]  # depot -> 1er client
        for i in range(len(route) - 1):
            cost += dist_matrix[route[i], route[i+1]]
        cost += dist_matrix[route[-1], depot]  # dernier client -> depot
    return cost

# === Construction d'une solution à partir d'une permutation et séparation en tournées ===
def split_routes(permutation, demands, capacity):
    routes = []
    route = []
    load = 0
    for node in permutation:
        demand = demands[node]
        if load + demand <= capacity:
            route.append(node)
            load += demand
        else:
            routes.append(route)
            route = [node]
            load = demand
    if route:
        routes.append(route)
    return routes

# === Initialisation population ===
def init_population(pop_size, n_customers):
    population = []
    base_perm = list(range(1, n_customers))  # exclure depot (0)
    for _ in range(pop_size):
        perm = base_perm[:]
        random.shuffle(perm)
        population.append(perm)
    return population

# === Sélection par tournoi ===
def tournament_selection(population, fitnesses, k=3):
    selected = random.sample(list(zip(population, fitnesses)), k)
    selected.sort(key=lambda x: x[1])
    return selected[0][0]

# === Crossover Order 1 (OX1) ===
def crossover(parent1, parent2):
    size = len(parent1)
    a, b = sorted(random.sample(range(size), 2))
    child = [None] * size
    child[a:b+1] = parent1[a:b+1]

    fill_pos = (b+1) % size
    parent2_pos = (b+1) % size
    while None in child:
        if parent2[parent2_pos] not in child:
            child[fill_pos] = parent2[parent2_pos]
            fill_pos = (fill_pos + 1) % size
        parent2_pos = (parent2_pos + 1) % size
    return child

# === Mutation swap ===
def mutation(perm, mutation_rate=0.002):
    perm = perm[:]
    for i in range(len(perm)):
        if random.random() < mutation_rate:
            j = random.randint(0, len(perm) -1)
            perm[i], perm[j] = perm[j], perm[i]
    return perm

# === Algorithme génétique principal ===
def genetic_algorithm(coords, demands, depot, capacity, dist_matrix,
                      pop_size=50, generations=200, mutation_rate=0.1):
    n_customers = len(coords)
    population = init_population(pop_size, n_customers)

    best_perm = None
    best_cost = float('inf')
    best_routes = None

    for gen in range(generations):
        fitnesses = []
        for perm in population:
            routes = split_routes(perm, demands, capacity)
            cost = calculate_cost(routes, dist_matrix)
            fitnesses.append(cost)

            if cost < best_cost:
                best_cost = cost
                best_perm = perm
                best_routes = routes

        new_population = []
        for _ in range(pop_size):
            parent1 = tournament_selection(population, fitnesses)
            parent2 = tournament_selection(population, fitnesses)
            child = crossover(parent1, parent2)
            child = mutation(child, mutation_rate)
            new_population.append(child)
        population = new_population

        if gen % 20 == 0:
            print(f"Gen {gen}: meilleur coût = {best_cost:.2f}")

    return best_routes, best_cost

# === Exécution 30 fois et sauvegarde des résultats ===
costs = []
num_routes = []
solutions = []
for i in range(30):
    print(f"Run {i+1}/30")
    routes, cost = genetic_algorithm(coords, demands, depot, capacity, dist_matrix)
    costs.append(cost)
    num_routes.append(len(routes))
    solutions.append((routes, cost))
    print(f"Coût total pour le run {i+1}: {cost:.2f}")

# === Meilleure solution globale ===
best_index = np.argmin(costs)
best_routes, best_cost = solutions[best_index]
best_num_routes = len(best_routes)

print(f"\nMeilleure solution sur 30 runs:")
print(f"Coût total = {best_cost:.2f}")
print(f"Nombre de tournées = {best_num_routes}")

# === Sauvegarde de la meilleure solution dans CSV ===
csv_filename = "best_solution_cvrp_b_n38_k6.csv"
with open(csv_filename, 'w', newline='') as csvfile:
    writer = csv.writer(csvfile)
    writer.writerow(['Route', 'Clients'])
    for i, route in enumerate(best_routes):
        clients_str = ' '.join(str(c+1) for c in route)
        writer.writerow([f"Tournée {i+1}", clients_str])

print(f"Meilleure solution sauvegardée dans {csv_filename}")

# === Tracé évolution du coût sur 30 runs ===
plt.figure(figsize=(10,5))
plt.plot(range(1,31), costs, marker='o')
plt.title("Évolution du coût total (distance) sur 30 runs - B-n38-k6")
plt.xlabel("Run")
plt.ylabel("Coût total")
plt.grid(True)
plt.show()

# === Tracé des tournées de la meilleure solution ===
plt.figure(figsize=(8,8))
colors = plt.cm.get_cmap('tab20', best_num_routes)

for i, route in enumerate(best_routes):
    route_coords = coords[np.array(route)]
    depot_coord = coords[depot]
    plt.plot(depot_coord[0], depot_coord[1], 'rs', markersize=8, label='Dépôt' if i == 0 else "")
    plt.plot([depot_coord[0], route_coords[0][0]], [depot_coord[1], route_coords[0][1]], color=colors(i))
    plt.plot(route_coords[:,0], route_coords[:,1], marker='o', color=colors(i), label=f"Tournée {i+1}")
    plt.plot([route_coords[-1][0], depot_coord[0]], [route_coords[-1][1], depot_coord[1]], color=colors(i))

plt.title("Meilleure solution CVRP (tournées) - B-n38-k6")
plt.legend()
plt.grid(True)
plt.show()

from google.colab import files
uploaded = files.upload()

import numpy as np
import matplotlib.pyplot as plt
import random
import re
import os
import urllib.request
import csv

# === Téléchargement de l'instance Li_32 ===
filename = 'Li_32.vrp'
url = 'http://vrp.galgos.inf.puc-rio.br/media/com_vrp/instances/Li/Li_32.vrp'

if not os.path.exists(filename):
    print("Téléchargement de l'instance Li_32...")
    urllib.request.urlretrieve(url, filename)
    print("Téléchargement terminé.")

# === Lecture du fichier VRP ===
def read_vrp_file(filename):
    with open(filename, 'r') as file:
        lines = file.readlines()

    dimension = int(re.search(r'DIMENSION\s*:\s*(\d+)', ''.join(lines)).group(1))
    capacity = int(re.search(r'CAPACITY\s*:\s*(\d+)', ''.join(lines)).group(1))

    node_coord_start = next(i for i, line in enumerate(lines) if 'NODE_COORD_SECTION' in line)
    demand_start = next(i for i, line in enumerate(lines) if 'DEMAND_SECTION' in line)
    depot_start = next(i for i, line in enumerate(lines) if 'DEPOT_SECTION' in line)

    coords = np.zeros((dimension, 2))
    for i in range(node_coord_start + 1, demand_start):
        parts = lines[i].split()
        coords[int(parts[0]) - 1] = [float(parts[1]), float(parts[2])]

    demands = np.zeros(dimension, dtype=int)
    for i in range(demand_start + 1, depot_start):
        parts = lines[i].split()
        demands[int(parts[0]) - 1] = int(parts[1])

    depot = int(lines[depot_start + 1].strip()) - 1
    return coords, demands, depot, capacity

coords, demands, depot, capacity = read_vrp_file(filename)

# === Calcul matrice de distances euclidiennes ===
def calculate_distance_matrix(coords):
    n = len(coords)
    dist_matrix = np.zeros((n, n))
    for i in range(n):
        for j in range(i+1, n):
            dist = np.linalg.norm(coords[i] - coords[j])
            dist_matrix[i, j] = dist
            dist_matrix[j, i] = dist
    return dist_matrix

dist_matrix = calculate_distance_matrix(coords)

# === Fonction coût total (somme distances tournées) ===
def calculate_cost(routes, dist_matrix):
    cost = 0
    for route in routes:
        if len(route) == 0:
            continue
        cost += dist_matrix[depot, route[0]]
        for i in range(len(route) - 1):
            cost += dist_matrix[route[i], route[i+1]]
        cost += dist_matrix[route[-1], depot]
    return cost

# === Séparation d'une permutation en tournées respectant la capacité ===
def split_routes(permutation, demands, capacity):
    routes = []
    route = []
    load = 0
    for node in permutation:
        demand = demands[node]
        if load + demand <= capacity:
            route.append(node)
            load += demand
        else:
            routes.append(route)
            route = [node]
            load = demand
    if route:
        routes.append(route)
    return routes

# === Initialisation population ===
def init_population(pop_size, n_customers):
    population = []
    base_perm = list(range(1, n_customers))
    for _ in range(pop_size):
        perm = base_perm[:]
        random.shuffle(perm)
        population.append(perm)
    return population

# === Sélection tournoi ===
def tournament_selection(population, fitnesses, k=3):
    selected = random.sample(list(zip(population, fitnesses)), k)
    selected.sort(key=lambda x: x[1])
    return selected[0][0]

# === Crossover Order 1 (OX1) ===
def crossover(parent1, parent2):
    size = len(parent1)
    a, b = sorted(random.sample(range(size), 2))
    child = [None] * size
    child[a:b+1] = parent1[a:b+1]

    fill_pos = (b+1) % size
    parent2_pos = (b+1) % size
    while None in child:
        if parent2[parent2_pos] not in child:
            child[fill_pos] = parent2[parent2_pos]
            fill_pos = (fill_pos + 1) % size
        parent2_pos = (parent2_pos + 1) % size
    return child

# === Mutation swap ===
def mutation(perm, mutation_rate=0.02):
    perm = perm[:]
    for i in range(len(perm)):
        if random.random() < mutation_rate:
            j = random.randint(0, len(perm) -1)
            perm[i], perm[j] = perm[j], perm[i]
    return perm

# === Algorithme génétique principal ===
def genetic_algorithm(coords, demands, depot, capacity, dist_matrix,
                      pop_size=50, generations=200, mutation_rate=0.15):
    n_customers = len(coords)
    population = init_population(pop_size, n_customers)

    best_perm = None
    best_cost = float('inf')
    best_routes = None

    for gen in range(generations):
        fitnesses = []
        for perm in population:
            routes = split_routes(perm, demands, capacity)
            cost = calculate_cost(routes, dist_matrix)
            fitnesses.append(cost)

            if cost < best_cost:
                best_cost = cost
                best_perm = perm
                best_routes = routes

        new_population = []
        for _ in range(pop_size):
            parent1 = tournament_selection(population, fitnesses)
            parent2 = tournament_selection(population, fitnesses)
            child = crossover(parent1, parent2)
            child = mutation(child, mutation_rate)
            new_population.append(child)
        population = new_population

        if gen % 25 == 0:
            print(f"Gen {gen}: meilleur coût = {best_cost:.2f}")

    return best_routes, best_cost

# === Exécution 30 runs ===
costs = []
num_routes = []
solutions = []
for i in range(30):
    print(f"Run {i+1}/30")
    routes, cost = genetic_algorithm(coords, demands, depot, capacity, dist_matrix)
    costs.append(cost)
    num_routes.append(len(routes))
    solutions.append((routes, cost))
    print(f"Coût total run {i+1}: {cost:.2f}")

# === Meilleure solution globale ===
best_index = np.argmin(costs)
best_routes, best_cost = solutions[best_index]
best_num_routes = len(best_routes)

print(f"\nMeilleure solution sur 30 runs:")
print(f"Coût total = {best_cost:.2f}")
print(f"Nombre de tournées = {best_num_routes}")

# === Sauvegarde CSV de la meilleure solution ===
csv_filename = "best_solution_cvrp_li_32.csv"
with open(csv_filename, 'w', newline='') as csvfile:
    writer = csv.writer(csvfile)
    writer.writerow(['Route', 'Clients'])
    for i, route in enumerate(best_routes):
        clients_str = ' '.join(str(c+1) for c in route)
        writer.writerow([f"Tournée {i+1}", clients_str])

print(f"Meilleure solution sauvegardée dans {csv_filename}")

# === Tracé évolution des coûts sur 30 runs ===
plt.figure(figsize=(10,5))
plt.plot(range(1,31), costs, marker='o')
plt.title("Évolution du coût total (distance) sur 30 runs - Li_32")
plt.xlabel("Run")
plt.ylabel("Coût total")
plt.grid(True)
plt.show()

# === Tracé des tournées de la meilleure solution ===
plt.figure(figsize=(10,10))
colors = plt.cm.get_cmap('tab20', best_num_routes)

for i, route in enumerate(best_routes):
    route_coords = coords[np.array(route)]
    depot_coord = coords[depot]
    plt.plot(depot_coord[0], depot_coord[1], 'rs', markersize=10, label='Dépôt' if i == 0 else "")
    plt.plot([depot_coord[0], route_coords[0][0]], [depot_coord[1], route_coords[0][1]], color=colors(i))
    plt.plot(route_coords[:,0], route_coords[:,1], marker='o', color=colors(i), label=f"Tournée {i+1}")
    plt.plot([route_coords[-1][0], depot_coord[0]], [route_coords[-1][1], depot_coord[1]], color=colors(i))

plt.title("Meilleure solution CVRP (tournées) - Li_32")
plt.legend()
plt.grid(True)
plt.show()

from google.colab import files
uploaded = files.upload()

import numpy as np
import matplotlib.pyplot as plt
import random
import re
import os
import urllib.request
import csv

# === Téléchargement de l'instance CMT12 ===
filename = 'CMT12.vrp'
url = 'http://vrp.galgos.inf.puc-rio.br/media/com_vrp/instances/CMT/CMT12.vrp'

if not os.path.exists(filename):
    print("Téléchargement de l'instance CMT12...")
    urllib.request.urlretrieve(url, filename)
    print("Téléchargement terminé.")

# === Lecture du fichier VRP ===
def read_vrp_file(filename):
    with open(filename, 'r') as file:
        lines = file.readlines()

    dimension = int(re.search(r'DIMENSION\s*:\s*(\d+)', ''.join(lines)).group(1))
    capacity = int(re.search(r'CAPACITY\s*:\s*(\d+)', ''.join(lines)).group(1))

    node_coord_start = next(i for i, line in enumerate(lines) if 'NODE_COORD_SECTION' in line)
    demand_start = next(i for i, line in enumerate(lines) if 'DEMAND_SECTION' in line)
    depot_start = next(i for i, line in enumerate(lines) if 'DEPOT_SECTION' in line)

    coords = np.zeros((dimension, 2))
    for i in range(node_coord_start + 1, demand_start):
        parts = lines[i].split()
        coords[int(parts[0]) - 1] = [float(parts[1]), float(parts[2])]

    demands = np.zeros(dimension, dtype=int)
    for i in range(demand_start + 1, depot_start):
        parts = lines[i].split()
        demands[int(parts[0]) - 1] = int(parts[1])

    depot = int(lines[depot_start + 1].strip()) - 1
    return coords, demands, depot, capacity

coords, demands, depot, capacity = read_vrp_file(filename)

# === Calcul matrice de distances euclidiennes ===
def calculate_distance_matrix(coords):
    n = len(coords)
    dist_matrix = np.zeros((n, n))
    for i in range(n):
        for j in range(i+1, n):
            dist = np.linalg.norm(coords[i] - coords[j])
            dist_matrix[i, j] = dist
            dist_matrix[j, i] = dist
    return dist_matrix

dist_matrix = calculate_distance_matrix(coords)

# === Fonction coût total (somme distances tournées) ===
def calculate_cost(routes, dist_matrix):
    cost = 0
    for route in routes:
        if len(route) == 0:
            continue
        cost += dist_matrix[depot, route[0]]
        for i in range(len(route) - 1):
            cost += dist_matrix[route[i], route[i+1]]
        cost += dist_matrix[route[-1], depot]
    return cost

# === Séparation d'une permutation en tournées respectant la capacité ===
def split_routes(permutation, demands, capacity):
    routes = []
    route = []
    load = 0
    for node in permutation:
        demand = demands[node]
        if load + demand <= capacity:
            route.append(node)
            load += demand
        else:
            routes.append(route)
            route = [node]
            load = demand
    if route:
        routes.append(route)
    return routes

# === Initialisation population ===
def init_population(pop_size, n_customers):
    population = []
    base_perm = list(range(1, n_customers))
    for _ in range(pop_size):
        perm = base_perm[:]
        random.shuffle(perm)
        population.append(perm)
    return population

# === Sélection tournoi ===
def tournament_selection(population, fitnesses, k=3):
    selected = random.sample(list(zip(population, fitnesses)), k)
    selected.sort(key=lambda x: x[1])
    return selected[0][0]

# === Crossover Order 1 (OX1) ===
def crossover(parent1, parent2):
    size = len(parent1)
    a, b = sorted(random.sample(range(size), 2))
    child = [None] * size
    child[a:b+1] = parent1[a:b+1]

    fill_pos = (b+1) % size
    parent2_pos = (b+1) % size
    while None in child:
        if parent2[parent2_pos] not in child:
            child[fill_pos] = parent2[parent2_pos]
            fill_pos = (fill_pos + 1) % size
        parent2_pos = (parent2_pos + 1) % size
    return child

# === Mutation swap ===
def mutation(perm, mutation_rate=0.1):
    perm = perm[:]
    for i in range(len(perm)):
        if random.random() < mutation_rate:
            j = random.randint(0, len(perm) -1)
            perm[i], perm[j] = perm[j], perm[i]
    return perm

# === Algorithme génétique principal ===
def genetic_algorithm(coords, demands, depot, capacity, dist_matrix,
                      pop_size=50, generations=200, mutation_rate=0.15):
    n_customers = len(coords)
    population = init_population(pop_size, n_customers)

    best_perm = None
    best_cost = float('inf')
    best_routes = None

    for gen in range(generations):
        fitnesses = []
        for perm in population:
            routes = split_routes(perm, demands, capacity)
            cost = calculate_cost(routes, dist_matrix)
            fitnesses.append(cost)

            if cost < best_cost:
                best_cost = cost
                best_perm = perm
                best_routes = routes

        new_population = []
        for _ in range(pop_size):
            parent1 = tournament_selection(population, fitnesses)
            parent2 = tournament_selection(population, fitnesses)
            child = crossover(parent1, parent2)
            child = mutation(child, mutation_rate)
            new_population.append(child)
        population = new_population

        if gen % 25 == 0:
            print(f"Gen {gen}: meilleur coût = {best_cost:.2f}")

    return best_routes, best_cost

# === Exécution 30 runs ===
costs = []
num_routes = []
solutions = []
for i in range(30):
    print(f"Run {i+1}/30")
    routes, cost = genetic_algorithm(coords, demands, depot, capacity, dist_matrix)
    costs.append(cost)
    num_routes.append(len(routes))
    solutions.append((routes, cost))
    print(f"Coût total run {i+1}: {cost:.2f}")

# === Meilleure solution globale ===
best_index = np.argmin(costs)
best_routes, best_cost = solutions[best_index]
best_num_routes = len(best_routes)

print(f"\nMeilleure solution sur 30 runs:")
print(f"Coût total = {best_cost:.2f}")
print(f"Nombre de tournées = {best_num_routes}")

# === Sauvegarde CSV de la meilleure solution ===
csv_filename = "best_solution_cvrp_cmt12.csv"
with open(csv_filename, 'w', newline='') as csvfile:
    writer = csv.writer(csvfile)
    writer.writerow(['Route', 'Clients'])
    for i, route in enumerate(best_routes):
        clients_str = ' '.join(str(c+1) for c in route)
        writer.writerow([f"Tournée {i+1}", clients_str])

print(f"Meilleure solution sauvegardée dans {csv_filename}")

# === Tracé évolution des coûts sur 30 runs ===
plt.figure(figsize=(10,5))
plt.plot(range(1,31), costs, marker='o')
plt.title("Évolution du coût total (distance) sur 30 runs - CMT12")
plt.xlabel("Run")
plt.ylabel("Coût total")
plt.grid(True)
plt.show()

# === Tracé des tournées de la meilleure solution ===
plt.figure(figsize=(10,10))
colors = plt.cm.get_cmap('tab20', best_num_routes)

for i, route in enumerate(best_routes):
    route_coords = coords[np.array(route)]
    depot_coord = coords[depot]
    plt.plot(depot_coord[0], depot_coord[1], 'rs', markersize=10, label='Dépôt' if i == 0 else "")
    plt.plot([depot_coord[0], route_coords[0][0]], [depot_coord[1], route_coords[0][1]], color=colors(i))
    plt.plot(route_coords[:,0], route_coords[:,1], marker='o', color=colors(i), label=f"Tournée {i+1}")
    plt.plot([route_coords[-1][0], depot_coord[0]], [route_coords[-1][1], depot_coord[1]], color=colors(i))

plt.title("Meilleure solution CVRP (tournées) - CMT12")
plt.legend()
plt.grid(True)
plt.show()

from google.colab import files
uploaded = files.upload()

import numpy as np
import matplotlib.pyplot as plt
import random
import re
import os
import urllib.request
import csv

# === Téléchargement de l'instance ORTEC-n242-k12 ===
filename = 'ORTEC-n242-k12.vrp'
url = 'https://vrp.galgos.inf.puc-rio.br/media/com_vrp/instances/ORTEC/ORTEC-n242-k12.vrp'

if not os.path.exists(filename):
    print("Téléchargement de l'instance ORTEC-n242-k12...")
    urllib.request.urlretrieve(url, filename)
    print("Téléchargement terminé.")

# === Lecture du fichier VRP ===
def read_vrp_file(filename):
    with open(filename, 'r') as file:
        lines = file.readlines()

    dimension = int(re.search(r'DIMENSION\s*:\s*(\d+)', ''.join(lines)).group(1))
    capacity = int(re.search(r'CAPACITY\s*:\s*(\d+)', ''.join(lines)).group(1))

    node_coord_start = next(i for i, line in enumerate(lines) if 'NODE_COORD_SECTION' in line)
    demand_start = next(i for i, line in enumerate(lines) if 'DEMAND_SECTION' in line)
    depot_start = next(i for i, line in enumerate(lines) if 'DEPOT_SECTION' in line)

    coords = np.zeros((dimension, 2))
    for i in range(node_coord_start + 1, demand_start):
        parts = lines[i].split()
        coords[int(parts[0]) - 1] = [float(parts[1]), float(parts[2])]

    demands = np.zeros(dimension, dtype=int)
    for i in range(demand_start + 1, depot_start):
        parts = lines[i].split()
        demands[int(parts[0]) - 1] = int(parts[1])

    depot = int(lines[depot_start + 1].strip()) - 1
    return coords, demands, depot, capacity

coords, demands, depot, capacity = read_vrp_file(filename)

# === Calcul matrice de distances euclidiennes ===
def calculate_distance_matrix(coords):
    n = len(coords)
    dist_matrix = np.zeros((n, n))
    for i in range(n):
        for j in range(i+1, n):
            dist = np.linalg.norm(coords[i] - coords[j])
            dist_matrix[i, j] = dist
            dist_matrix[j, i] = dist
    return dist_matrix

dist_matrix = calculate_distance_matrix(coords)

# === Fonction coût total (somme distances tournées) ===
def calculate_cost(routes, dist_matrix):
    cost = 0
    for route in routes:
        if len(route) == 0:
            continue
        cost += dist_matrix[depot, route[0]]
        for i in range(len(route) - 1):
            cost += dist_matrix[route[i], route[i+1]]
        cost += dist_matrix[route[-1], depot]
    return cost

# === Séparation d'une permutation en tournées respectant la capacité ===
def split_routes(permutation, demands, capacity):
    routes = []
    route = []
    load = 0
    for node in permutation:
        demand = demands[node]
        if load + demand <= capacity:
            route.append(node)
            load += demand
        else:
            routes.append(route)
            route = [node]
            load = demand
    if route:
        routes.append(route)
    return routes

# === Initialisation population ===
def init_population(pop_size, n_customers):
    population = []
    base_perm = list(range(1, n_customers))
    for _ in range(pop_size):
        perm = base_perm[:]
        random.shuffle(perm)
        population.append(perm)
    return population

# === Sélection tournoi ===
def tournament_selection(population, fitnesses, k=3):
    selected = random.sample(list(zip(population, fitnesses)), k)
    selected.sort(key=lambda x: x[1])
    return selected[0][0]

# === Crossover Order 1 (OX1) ===
def crossover(parent1, parent2):
    size = len(parent1)
    a, b = sorted(random.sample(range(size), 2))
    child = [None] * size
    child[a:b+1] = parent1[a:b+1]

    fill_pos = (b+1) % size
    parent2_pos = (b+1) % size
    while None in child:
        if parent2[parent2_pos] not in child:
            child[fill_pos] = parent2[parent2_pos]
            fill_pos = (fill_pos + 1) % size
        parent2_pos = (parent2_pos + 1) % size
    return child

# === Mutation swap ===
def mutation(perm, mutation_rate=0.02):
    perm = perm[:]
    for i in range(len(perm)):
        if random.random() < mutation_rate:
            j = random.randint(0, len(perm) -1)
            perm[i], perm[j] = perm[j], perm[i]
    return perm

# === Algorithme génétique principal ===
def genetic_algorithm(coords, demands, depot, capacity, dist_matrix,
                      pop_size=100, generations=500, mutation_rate=0.15):
    n_customers = len(coords)
    population = init_population(pop_size, n_customers)

    best_perm = None
    best_cost = float('inf')
    best_routes = None

    for gen in range(generations):
        fitnesses = []
        for perm in population:
            routes = split_routes(perm, demands, capacity)
            cost = calculate_cost(routes, dist_matrix)
            fitnesses.append(cost)

            if cost < best_cost:
                best_cost = cost
                best_perm = perm
                best_routes = routes

        new_population = []
        for _ in range(pop_size):
            parent1 = tournament_selection(population, fitnesses)
            parent2 = tournament_selection(population, fitnesses)
            child = crossover(parent1, parent2)
            child = mutation(child, mutation_rate)
            new_population.append(child)
        population = new_population

        if gen % 25 == 0:
            print(f"Gen {gen}: meilleur coût = {best_cost:.2f}")

    return best_routes, best_cost

# === Exécution 30 runs ===
costs = []
num_routes = []
solutions = []
for i in range(30):
    print(f"Run {i+1}/30")
    routes, cost = genetic_algorithm(coords, demands, depot, capacity, dist_matrix)
    costs.append(cost)
    num_routes.append(len(routes))
    solutions.append((routes, cost))
    print(f"Coût total run {i+1}: {cost:.2f}")

# === Meilleure solution globale ===
best_index = np.argmin(costs)
best_routes, best_cost = solutions[best_index]
best_num_routes = len(best_routes)

print(f"\nMeilleure solution sur 30 runs:")
print(f"Coût total = {best_cost:.2f}")
print(f"Nombre de tournées = {best_num_routes}")

# === Sauvegarde CSV de la meilleure solution ===
csv_filename = "best_solution_cvrp_ortec_n242_k12.csv"
with open(csv_filename, 'w', newline='') as csvfile:
    writer = csv.writer(csvfile)
    writer.writerow(['Route', 'Clients'])
    for i, route in enumerate(best_routes):
        clients_str = ' '.join(str(c+1) for c in route)
        writer.writerow([f"Tournée {i+1}", clients_str])

print(f"Meilleure solution sauvegardée dans {csv_filename}")

# === Tracé évolution des coûts sur 30 runs ===
plt.figure(figsize=(10,5))
plt.plot(range(1,31), costs, marker='o')
plt.title("Évolution du coût total (distance) sur 30 runs - ORTEC-n242-k12")
plt.xlabel("Run")
plt.ylabel("Coût total")
plt.grid(True)
plt.show()

# === Tracé des tournées de la meilleure solution ===
plt.figure(figsize=(10,10))
colors = plt.cm.get_cmap('tab20', best_num_routes)

for i, route in enumerate(best_routes):
    route_coords = coords[np.array(route)]
    depot_coord = coords[depot]
    plt.plot(depot_coord[0], depot_coord[1], 'rs', markersize=10, label='Dépôt' if i == 0 else "")
    plt.plot([depot_coord[0], route_coords[0][0]], [depot_coord[1], route_coords[0][1]], color=colors(i))
    plt.plot(route_coords[:,0], route_coords[:,1], marker='o', color=colors(i), label=f"Tournée {i+1}")
    plt.plot([route_coords[-1][0], depot_coord[0]], [route_coords[-1][1], depot_coord[1]], color=colors(i))

plt.title("Meilleure solution CVRP (tournées) - ORTEC-n242-k12")
plt.legend()
plt.grid(True)
plt.show()

import numpy as np
import matplotlib.pyplot as plt
import random
import re
import csv

from google.colab import files
uploaded = files.upload()

import numpy as np
import matplotlib.pyplot as plt
import csv
import random
import re
import time

# === Lecture fichier VRP pour tai75a.vrp ===
def read_vrp_file(filename):
    with open(filename, 'r') as file:
        lines = file.readlines()

    dimension = int(re.search(r'DIMENSION\s*:\s*(\d+)', ''.join(lines)).group(1))
    capacity = int(re.search(r'CAPACITY\s*:\s*(\d+)', ''.join(lines)).group(1))

    node_coord_start = next(i for i, line in enumerate(lines) if 'NODE_COORD_SECTION' in line)
    demand_start = next(i for i, line in enumerate(lines) if 'DEMAND_SECTION' in line)
    depot_start = next(i for i, line in enumerate(lines) if 'DEPOT_SECTION' in line)

    coords = np.zeros((dimension, 2))
    for i in range(node_coord_start + 1, demand_start):
        parts = lines[i].split()
        coords[int(parts[0]) - 1] = [float(parts[1]), float(parts[2])]

    demands = np.zeros(dimension, dtype=int)
    for i in range(demand_start + 1, depot_start):
        parts = lines[i].split()
        demands[int(parts[0]) - 1] = int(parts[1])

    depot = int(lines[depot_start + 1].strip()) - 1
    return coords, demands, depot, capacity

coords, demands, depot, capacity = read_vrp_file('tai75a.vrp')

# === Matrice de distances euclidiennes ===
def calculate_distance_matrix(coords):
    n = len(coords)
    dist_matrix = np.zeros((n, n))
    for i in range(n):
        for j in range(i+1, n):
            dist = np.linalg.norm(coords[i] - coords[j])
            dist_matrix[i, j] = dist
            dist_matrix[j, i] = dist
    return dist_matrix

dist_matrix = calculate_distance_matrix(coords)

# === Calcul du coût ===
def calculate_cost(routes, dist_matrix):
    cost = 0
    for route in routes:
        if len(route) == 0:
            continue
        cost += dist_matrix[depot, route[0]]
        for i in range(len(route) - 1):
            cost += dist_matrix[route[i], route[i+1]]
        cost += dist_matrix[route[-1], depot]
    return cost

# === Split en tournées ===
def split_routes(permutation, demands, capacity):
    routes = []
    route = []
    load = 0
    for node in permutation:
        demand = demands[node]
        if load + demand <= capacity:
            route.append(node)
            load += demand
        else:
            routes.append(route)
            route = [node]
            load = demand
    if route:
        routes.append(route)
    return routes

# === Population initiale ===
def init_population(pop_size, n_customers):
    population = []
    base_perm = list(range(1, n_customers))  # exclure dépôt (0)
    for _ in range(pop_size):
        perm = base_perm[:]
        random.shuffle(perm)
        population.append(perm)
    return population

# === Sélection par tournoi ===
def tournament_selection(population, fitnesses, k=3):
    selected = random.sample(list(zip(population, fitnesses)), k)
    selected.sort(key=lambda x: x[1])
    return selected[0][0]

def pmx_crossover(parent1, parent2):
    size = len(parent1)
    a, b = sorted(random.sample(range(size), 2))

    # Initialisation des enfants
    child = [None] * size

    # Copier le segment du parent1
    child[a:b+1] = parent1[a:b+1]

    # Création d’un mapping entre les gènes croisés
    mapping = {}
    for i in range(a, b+1):
        mapping[parent2[i]] = parent1[i]

    # Remplir les positions restantes
    for i in range(size):
        if i >= a and i <= b:
            continue
        gene = parent2[i]
        while gene in mapping:
            gene = mapping[gene]
        child[i] = gene

    return child
# === Mutation par swap ===
def mutation(perm, mutation_rate=0.02):
    perm = perm[:]
    for i in range(len(perm)):
        if random.random() < mutation_rate:
            j = random.randint(0, len(perm) -1)
            perm[i], perm[j] = perm[j], perm[i]
    return perm

# === Algorithme génétique ===
def genetic_algorithm(coords, demands, depot, capacity, dist_matrix,
                      pop_size=50, generations=100, mutation_rate=0.1):
    n_customers = len(coords)
    population = init_population(pop_size, n_customers)

    best_perm = None
    best_cost = float('inf')
    best_routes = None

    for gen in range(generations):
        fitnesses = []
        for perm in population:
            routes = split_routes(perm, demands, capacity)
            cost = calculate_cost(routes, dist_matrix)
            fitnesses.append(cost)

            if cost < best_cost:
                best_cost = cost
                best_perm = perm
                best_routes = routes

        new_population = []
        for _ in range(pop_size):
            parent1 = tournament_selection(population, fitnesses)
            parent2 = tournament_selection(population, fitnesses)
            child = crossover(parent1, parent2)
            child = mutation(child, mutation_rate)
            new_population.append(child)
        population = new_population

    return best_routes, best_cost

# === Exécution 30 fois avec calcul du temps total ===
start_time = time.time()

costs = []
num_routes = []
solutions = []

for i in range(30):
    print(f"Run {i+1}/30")
    routes, cost = genetic_algorithm(coords, demands, depot, capacity, dist_matrix)
    costs.append(cost)
    num_routes.append(len(routes))
    solutions.append((routes, cost))
    print(f"Coût total pour le run {i+1}: {cost:.2f}")

end_time = time.time()
total_time = end_time - start_time

# === Meilleure solution ===
best_index = np.argmin(costs)
best_routes, best_cost = solutions[best_index]
best_num_routes = len(best_routes)

print(f"\nMeilleure solution sur 30 runs:")
print(f"Coût total = {best_cost:.2f}")
print(f"Nombre de tournées = {best_num_routes}")
print(f"\n⏱ Temps total d'exécution des 30 runs : {total_time:.2f} secondes")

# === Sauvegarde CSV ===
csv_filename = "best_solution_tai75a.csv"
with open(csv_filename, 'w', newline='') as csvfile:
    writer = csv.writer(csvfile)
    writer.writerow(['Route', 'Clients'])
    for i, route in enumerate(best_routes):
        clients_str = ' '.join(str(c+1) for c in route)
        writer.writerow([f"Tournée {i+1}", clients_str])
print(f"Meilleure solution sauvegardée dans {csv_filename}")

# === Plot coût par run ===
plt.figure(figsize=(10,5))
plt.plot(range(1,31), costs, marker='o')
plt.title("Évolution du coût total (distance) sur 30 runs - tai75a")
plt.xlabel("Run")
plt.ylabel("Coût total")
plt.grid(True)
plt.show()

# === Plot meilleure solution ===
plt.figure(figsize=(8,8))
colors = plt.cm.get_cmap('tab20', best_num_routes)

for i, route in enumerate(best_routes):
    route_coords = coords[np.array(route)]
    depot_coord = coords[depot]
    plt.plot(depot_coord[0], depot_coord[1], 'rs', markersize=8, label='Dépôt' if i == 0 else "")
    plt.plot([depot_coord[0], route_coords[0][0]], [depot_coord[1], route_coords[0][1]], color=colors(i))
    plt.plot(route_coords[:,0], route_coords[:,1], marker='o', color=colors(i), label=f"Tournée {i+1}")
    plt.plot([route_coords[-1][0], depot_coord[0]], [route_coords[-1][1], depot_coord[1]], color=colors(i))

plt.title("Meilleure solution CVRP (tournées) - tai75a")
plt.legend()
plt.grid(True)
plt.show()
# Affichage
plot_routes(solution, coords)
plot_convergence_curve(cost_history)

from google.colab import files
uploaded = files.upload()

import numpy as np
import matplotlib.pyplot as plt
import random
import math
import re
import time

# ---------------- Lecture de l'instance ---------------- #
def read_vrp_euc_2d(filename):
    with open(filename, 'r') as f:
        lines = f.readlines()

    capacity = int(re.search(r'CAPACITY\s*:\s*(\d+)', ''.join(lines)).group(1))

    node_coord_start = next(i for i, line in enumerate(lines) if 'NODE_COORD_SECTION' in line) + 1
    demand_start = next(i for i, line in enumerate(lines) if 'DEMAND_SECTION' in line) + 1
    depot_start = next(i for i, line in enumerate(lines) if 'DEPOT_SECTION' in line) + 1

    coords = []
    for line in lines[node_coord_start:demand_start - 1]:
        parts = line.strip().split()
        coords.append((float(parts[1]), float(parts[2])))

    demands = []
    for line in lines[demand_start:depot_start - 1]:
        parts = line.strip().split()
        demands.append(int(parts[1]))

    depot = int(lines[depot_start].strip()) - 1

    n = len(coords)
    dist_matrix = np.zeros((n, n))
    for i in range(n):
        for j in range(n):
            dx = coords[i][0] - coords[j][0]
            dy = coords[i][1] - coords[j][1]
            dist_matrix[i][j] = math.hypot(dx, dy)

    return coords, demands, depot, capacity, dist_matrix

# ---------------- Outils AG ---------------- #
def calculate_total_distance(solution, dist_matrix):
    return sum(dist_matrix[route[i]][route[i+1]] for route in solution for i in range(len(route)-1))

def initialize_population(pop_size, num_clients):
    return [random.sample(range(1, num_clients), num_clients - 1) for _ in range(pop_size)]

def split_routes(individual, demands, capacity):
    routes = []
    route = [0]
    load = 0
    for client in individual:
        if load + demands[client] <= capacity:
            route.append(client)
            load += demands[client]
        else:
            route.append(0)
            routes.append(route)
            route = [0, client]
            load = demands[client]
    route.append(0)
    routes.append(route)
    return routes

def tournament_selection(population, fitnesses, k=3):
    selected = random.sample(list(zip(population, fitnesses)), k)
    return min(selected, key=lambda x: x[1])[0]

def pmx_crossover(p1, p2):
    size = len(p1)
    c = [-1]*size
    cx1, cx2 = sorted(random.sample(range(size), 2))
    c[cx1:cx2+1] = p1[cx1:cx2+1]
    for i in range(cx1, cx2+1):
        if p2[i] not in c:
            val = p2[i]
            pos = i
            while True:
                val_in_p1 = p1[pos]
                if val_in_p1 not in c:
                    pos = p2.index(val_in_p1)
                else:
                    break
            c[pos] = val
    for i in range(size):
        if c[i] == -1:
            c[i] = p2[i]
    return c

# ---------------- Mutation guidée par DQN ---------------- #
# Fictive pour l’exemple : sélectionne la meilleure parmi N mutations aléatoires
def dqn_mutation(individual, dqn_model, dist_matrix, demands, capacity, mutation_rate=0.02):
    if random.random() < mutation_rate:
        k = 5
        candidates = []
        costs = []
        for _ in range(k):
            mutated = individual[:]
            i, j = sorted(random.sample(range(len(mutated)), 2))
            mutated[i], mutated[j] = mutated[j], mutated[i]
            routes = split_routes(mutated, demands, capacity)
            cost = calculate_total_distance(routes, dist_matrix)
            candidates.append(mutated)
            costs.append(cost)
        best_idx = np.argmin(costs)
        return candidates[best_idx]
    return individual

# ---------------- Algorithme génétique avec DQN ---------------- #
def genetic_algorithm_dqn(demands, depot, capacity, dist_matrix, dqn_model,
                          generations=100, pop_size=50, return_history=False):
    num_clients = len(demands)
    population = initialize_population(pop_size, num_clients)
    best_costs_per_gen = []

    for gen in range(generations):
        fitnesses = []
        for individual in population:
            routes = split_routes(individual, demands, capacity)
            cost = calculate_total_distance(routes, dist_matrix)
            fitnesses.append(cost)

        best_costs_per_gen.append(min(fitnesses))

        new_population = []
        for _ in range(pop_size):
            p1 = tournament_selection(population, fitnesses)
            p2 = tournament_selection(population, fitnesses)
            child = pmx_crossover(p1, p2)
            child = dqn_mutation(child, dqn_model, dist_matrix, demands, capacity)
            new_population.append(child)

        population = new_population

    best_cost = float('inf')
    best_solution = None
    for individual in population:
        routes = split_routes(individual, demands, capacity)
        cost = calculate_total_distance(routes, dist_matrix)
        if cost < best_cost:
            best_cost = cost
            best_solution = routes

    if return_history:
        return best_solution, best_cost, best_costs_per_gen
    else:
        return best_solution, best_cost

# ---------------- Visualisation ---------------- #
def plot_routes(routes, coords):
    plt.figure(figsize=(8, 6))
    for route in routes:
        xs = [coords[i][0] for i in route]
        ys = [coords[i][1] for i in route]
        plt.plot(xs, ys, marker='o')
    plt.scatter(coords[0][0], coords[0][1], c='red', s=100, label='Depot')
    plt.title("Tournées optimisées (AG + DQN)")
    plt.legend()
    plt.grid()
    plt.show()

def plot_convergence_curve(costs_per_gen):
    plt.figure(figsize=(8, 5))
    plt.plot(range(len(costs_per_gen)), costs_per_gen, marker='o', color='blue')
    plt.title("Courbe de convergence du coût")
    plt.xlabel("Génération")
    plt.ylabel("Meilleur coût")
    plt.grid(True)
    plt.tight_layout()
    plt.show()

# ---------------- MAIN ---------------- #
# Exemple fictif de dqn_model (aucun modèle réel nécessaire ici)
class DummyDQN:
    def predict(self, state_batch, verbose=0):
        # Retourne des valeurs aléatoires comme Q-values
        batch_size = len(state_batch)
        num_actions = len(state_batch[0]) if batch_size > 0 else 1
        return np.random.rand(batch_size, num_actions)


# Charger instance
coords, demands, depot, capacity, dist_matrix = read_vrp_euc_2d("F-n45-k4.vrp")

# Appliquer AG + DQN
start_time = time.time()
solution, cost, cost_history = genetic_algorithm_dqn(
    demands, depot, capacity, dist_matrix, dqn_model=DummyDQN(),
    generations=100, pop_size=50, return_history=True
)
end_time = time.time()

print(f"✅ Coût final = {cost:.2f}")
print(f"⏱️ Temps total : {end_time - start_time:.2f} secondes")

# Affichage
plot_routes(solution, coords)
plot_convergence_curve(cost_history)

from google.colab import files
uploaded = files.upload()

import numpy as np
import matplotlib.pyplot as plt
import csv
import random
import re
import time

# === Lecture fichier VRP ===
def read_vrp_file(filename):
    with open(filename, 'r') as file:
        lines = file.readlines()

    dimension = int(re.search(r'DIMENSION\s*:\s*(\d+)', ''.join(lines)).group(1))
    capacity = int(re.search(r'CAPACITY\s*:\s*(\d+)', ''.join(lines)).group(1))

    node_coord_start = next(i for i, line in enumerate(lines) if 'NODE_COORD_SECTION' in line)
    demand_start = next(i for i, line in enumerate(lines) if 'DEMAND_SECTION' in line)
    depot_start = next(i for i, line in enumerate(lines) if 'DEPOT_SECTION' in line)

    coords = np.zeros((dimension, 2))
    for i in range(node_coord_start + 1, demand_start):
        parts = lines[i].split()
        coords[int(parts[0]) - 1] = [float(parts[1]), float(parts[2])]

    demands = np.zeros(dimension, dtype=int)
    for i in range(demand_start + 1, depot_start):
        parts = lines[i].split()
        demands[int(parts[0]) - 1] = int(parts[1])

    depot = int(lines[depot_start + 1].strip()) - 1
    return coords, demands, depot, capacity

# === Calcul matrice distance euclidienne ===
def calculate_distance_matrix(coords):
    n = len(coords)
    dist_matrix = np.zeros((n, n))
    for i in range(n):
        for j in range(i+1, n):
            dist = np.linalg.norm(coords[i] - coords[j])
            dist_matrix[i, j] = dist
            dist_matrix[j, i] = dist
    return dist_matrix

# === Calcul du coût total d’une solution (liste de tournées) ===
def calculate_cost(routes, dist_matrix, depot):
    cost = 0
    for route in routes:
        if len(route) == 0:
            continue
        cost += dist_matrix[depot, route[0]]
        for i in range(len(route) - 1):
            cost += dist_matrix[route[i], route[i+1]]
        cost += dist_matrix[route[-1], depot]
    return cost

# === Découpage permutation en tournées selon capacité ===
def split_routes(permutation, demands, capacity):
    routes = []
    route = []
    load = 0
    for node in permutation:
        demand = demands[node]
        if load + demand <= capacity:
            route.append(node)
            load += demand
        else:
            routes.append(route)
            route = [node]
            load = demand
    if route:
        routes.append(route)
    return routes

# === Initialisation population (permutations sans dépôt) ===
def init_population(pop_size, n_customers):
    population = []
    base_perm = list(range(1, n_customers))  # exclure dépôt = 0
    for _ in range(pop_size):
        perm = base_perm[:]
        random.shuffle(perm)
        population.append(perm)
    return population

# === Sélection par tournoi (k=3) ===
def tournament_selection(population, fitnesses, k=3):
    selected = random.sample(list(zip(population, fitnesses)), k)
    selected.sort(key=lambda x: x[1])
    return selected[0][0]

# === PMX crossover ===
def pmx_crossover(parent1, parent2):
    size = len(parent1)
    a, b = sorted(random.sample(range(size), 2))

    child = [None] * size
    child[a:b+1] = parent1[a:b+1]

    mapping = {}
    for i in range(a, b+1):
        mapping[parent2[i]] = parent1[i]

    for i in range(size):
        if i >= a and i <= b:
            continue
        gene = parent2[i]
        while gene in mapping:
            gene = mapping[gene]
        child[i] = gene

    return child

# === Mutation par échange (swap) ===
def mutation(perm, mutation_rate=0.1):
    perm = perm[:]
    for i in range(len(perm)):
        if random.random() < mutation_rate:
            j = random.randint(0, len(perm) - 1)
            perm[i], perm[j] = perm[j], perm[i]
    return perm

# === Algorithme génétique complet ===
def genetic_algorithm(coords, demands, depot, capacity, dist_matrix,
                      pop_size=30, generations=50, mutation_rate=0.1):
    n_customers = len(coords)
    population = init_population(pop_size, n_customers)

    best_perm = None
    best_cost = float('inf')
    best_routes = None
    cost_history = []

    for gen in range(generations):
        fitnesses = []
        for perm in population:
            routes = split_routes(perm, demands, capacity)
            cost = calculate_cost(routes, dist_matrix, depot)
            fitnesses.append(cost)

            if cost < best_cost:
                best_cost = cost
                best_perm = perm
                best_routes = routes

        cost_history.append(best_cost)

        new_population = []
        for _ in range(pop_size):
            parent1 = tournament_selection(population, fitnesses)
            parent2 = tournament_selection(population, fitnesses)
            child = pmx_crossover(parent1, parent2)
            child = mutation(child, mutation_rate)
            new_population.append(child)
        population = new_population

    return best_routes, best_cost, cost_history

# === Chargement instance ===
coords, demands, depot, capacity = read_vrp_file('tai75a.vrp')
dist_matrix = calculate_distance_matrix(coords)

# === Exécution 30 runs ===
n_runs = 30
costs = []
num_routes = []
all_cost_histories = []
solutions = []

start_time = time.time()
for i in range(n_runs):
    print(f"Run {i+1}/{n_runs}")
    routes, cost, cost_history = genetic_algorithm(coords, demands, depot, capacity, dist_matrix,
                                                   pop_size=30, generations=50, mutation_rate=0.1)
    costs.append(cost)
    num_routes.append(len(routes))
    all_cost_histories.append(cost_history)
    solutions.append((routes, cost))
    print(f"Coût total: {cost:.2f}")

end_time = time.time()
print(f"\nTemps total pour {n_runs} runs : {end_time - start_time:.2f} secondes")

# === Meilleure solution parmi les 30 runs ===
best_index = np.argmin(costs)
best_routes, best_cost = solutions[best_index]
best_num_routes = len(best_routes)

print(f"\nMeilleure solution : coût = {best_cost:.2f}, tournées = {best_num_routes}")

# === Affichage coût par run ===
plt.figure(figsize=(10,5))
plt.plot(range(1, n_runs+1), costs, marker='o')
plt.title("Coût total par run - tai75a")
plt.xlabel("Run")
plt.ylabel("Coût total")
plt.grid(True)
plt.show()

# === Affichage courbe de convergence du meilleur run ===
plt.figure(figsize=(10,5))
plt.plot(all_cost_histories[best_index], marker='o')
plt.title("Courbe de convergence (meilleur run)")
plt.xlabel("Génération")
plt.ylabel("Coût")
plt.grid(True)
plt.show()

# === Affichage meilleure solution (tournées) ===
plt.figure(figsize=(8,8))
colors = plt.cm.get_cmap('tab20', best_num_routes)
depot_coord = coords[depot]
plt.plot(depot_coord[0], depot_coord[1], 'rs', markersize=10, label='Dépôt')

for i, route in enumerate(best_routes):
    route_coords = coords[np.array(route)]
    plt.plot([depot_coord[0], route_coords[0][0]], [depot_coord[1], route_coords[0][1]], color=colors(i))
    plt.plot(route_coords[:,0], route_coords[:,1], marker='o', color=colors(i), label=f"Tournée {i+1}")
    plt.plot([route_coords[-1][0], depot_coord[0]], [route_coords[-1][1], depot_coord[1]], color=colors(i))

plt.title("Meilleure solution CVRP - tai75a")
plt.legend()
plt.grid(True)
plt.show()

# === Sauvegarde meilleure solution dans CSV ===
csv_filename = "best_solution_tai75a.csv"
with open(csv_filename, 'w', newline='') as csvfile:
    writer = csv.writer(csvfile)
    writer.writerow(['Route', 'Clients'])
    for i, route in enumerate(best_routes):
        clients_str = ' '.join(str(c+1) for c in route)  # +1 pour indice client humain
        writer.writerow([f"Tournée {i+1}", clients_str])
print(f"Meilleure solution sauvegardée dans {csv_filename}")
